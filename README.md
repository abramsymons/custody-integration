# Zellular Custody Service Integration

Integrating with the Zellular custody service involves three core steps:

1. **Generating deposit addresses** for users
2. **Verifying and parsing deposit transactions** received from the custody service
3. **Submitting withdrawal requests** to send funds to user-specified destinations

---

## 1. Generating Deposit Addresses

Zellular uses deterministic address derivation, which allows your application to generate deposit addresses locally without querying the custody service. These addresses are unique per user and per chain.

### Bitcoin Networks

On Bitcoin, deposit addresses are derived from:
- A shared **verifying public key** provided by the custody service
- The user's **custody ID** (a sequential integer starting from `0`)

### EVM-Compatible Chains

On EVM-based chains, addresses are derived from:
- The **factory contract address**
- The **factory's bytecode hash**
- The user's **custody ID**

### Custody User IDs

The custody service assigns each user a **sequential integer ID**, starting at `0`. Your application must:

- Maintain a mapping between your internal user IDs and custody user IDs
- Use this mapping to resolve deposit events and credit users correctly

When a deposit occurs, the custody service sends a deposit request that includes the custody-assigned user ID. Your application is responsible for linking this ID to the appropriate internal user.

### Declare User Count for Monitoring

To tell the custody service how many users to monitor deposit addresses for, your application must expose the following route:

```python
@router.get("/users/latest-id")
async def get_latest_user_id() -> dict[str, int]:
    return {"id": NUMBER_OF_USERS}
```

- This route returns the **latest (highest) custody user ID** your app wants monitored.
- The custody service will derive addresses and monitor chains for all users from `0` to `id`.

### Example Scripts

Use the provided helper scripts to generate deposit addresses for testing or indexing:

- `id2address_btc.py`: Generates Bitcoin deposit addresses for the first N users
- `id2address_evm.py`: Generates EVM-compatible deposit addresses for the first N users

These can be used to precompute or validate user deposit addresses based on your mapping.

---

## 2. Receiving, Verifying, and Parsing Deposit Transactions

When a deposit is detected on a custody-managed address, the custody service will notify your application by calling the following endpoint:

```python
@router.post("/deposit")
async def deposit(txs: list[str]) -> dict[str, bool]:
    txs = [tx.encode("latin-1") for tx in txs]
    for tx in txs:
        # process deposit txs
```

- Each `tx` is a raw transaction serialized as a Latin-1 string.
- Your application must decode, verify, and process each transaction accordingly.

### Verifying Deposit Transactions

Each transaction includes two signature layers:

1. **FROST Signature**: A threshold Schnorr signature generated by a quorum of custody nodes.  
2. **ECDSA Shield Signature**: A centralized ECDSA signature from the custody shield server.

Both signatures must be verified for the deposit to be considered valid.

ðŸ“„ See `verify_deposit.py` for the complete implementation of the verification logic.

### Parsing a Verified Deposit Transaction

Once a transaction is verified, your application must parse its binary payload to extract one or more deposit events. Each event includes the deposit amount, user ID, token contract, destination, and more.

ðŸ“„ See `parse_deposit.py` for the full parsing logic and format specification.

---

## 3. Submitting Withdrawal Requests

The custody service queries your application for pending withdrawals to sign and submit on-chain. Your app must implement two endpoints:

### Get Last Withdrawal ID

Returns the last processed withdrawal ID for a given chain.

```python
@router.get("/withdraw/id/last")
def get_last_withdraw_id(chain: str = Query(...)) -> dict[str, int | str]:
    return {"chain": chain, "id": 0}
```

### Get Pending Withdrawals

Returns a paginated list of unsigned withdrawal requests.

```python
@router.get("/withdraws", response_model=list[Withdraw])
def get_withdraws(
    chain: str = Query(...),
    offset: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    ...
```

 **Query Parameters:**

- `chain`: Chain name (e.g., `"SEP"`)
- `offset`: Pagination offset (default: `0`)
- `limit`: Maximum number of withdrawals to return (default: `10`)


ðŸ“„ See `main.py` for the full implementation of the routes that the application should serve and be queried by the custody service.

---

## Run and Test the Server

Install dependencies:

```bash
uv venv
uv pip install -r requirements.txt
```

Start your FastAPI server:

```bash
uv run uvicorn main:app --reload
```

To test the `/deposit` route manually, you can use `curl` with a JSON file that contains `Latin-1` encoded deposit transactions:

```bash
curl -X POST http://localhost:8000/deposit \
  -H "Content-Type: application/json" \
  -d @payload.json
```

Where `payload.json` contains a valid deposit transaction.
