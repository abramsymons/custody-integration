# Zellular Custody Service Integration

Integrating with the Zellular custody service involves three core steps:

1. **Generating deposit addresses** for users
2. **Verifying and parsing deposit transactions** received from the custody service
3. **Submitting withdrawal requests** to send funds to user-specified destinations

---

## 1. Generating Deposit Addresses

Zellular uses deterministic address derivation, allowing your application to generate deposit addresses locally without querying the custody service. These addresses are unique per user and per chain.

The custody service queries the salts from your application and uses them to generate and monitor deposit addresses.

### Bitcoin Networks

On Bitcoin, deposit addresses are derived from:
- A shared **verifying public key** provided by the custody service
- A **salt** â€” a unique integer per user defined by your app

### EVM-Compatible Chains

On EVM-based chains, addresses are derived from:
- The **factory contract address**
- The **factory's bytecode hash**
- The **salt** â€” a unique integer per user defined by your app

### Get the Count of Users

The custody service first queries this route to find out the count of users:

```python
@router.get("/user/count")
async def get_user_count() -> dict[str, int]:
    return {"count": 10}
```

### Get Users Salts

This route returns a paginated list of users with their assigned salts:

```python
class User(BaseModel):
    salt: int
    id: int

@router.get("/users", response_model=list[User])
def get_users(
    offset: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    ...
```

### Example Scripts

Use the provided helper scripts to generate deposit addresses for testing or indexing:

- `id2address_btc.py`: Generates Bitcoin deposit addresses for a set of sample salts.
- `id2address_evm.py`: Generates EVM-compatible deposit addresses for a set of sample salts.

These scripts can be used to precompute or validate user deposit addresses based on your application's salt mapping.

---

## 2. Receiving, Verifying, and Parsing Deposit Transactions

When a deposit is detected on a custody-managed address, the custody service will notify your application by calling the following endpoint:

```python
@router.post("/deposit")
async def deposit(txs: list[str]) -> dict[str, bool]:
    txs = [tx.encode("latin-1") for tx in txs]
    for tx in txs:
        # process deposit txs
```

- Each `tx` is a raw transaction serialized as a Latin-1 string.
- Your application must decode, verify, and process each transaction accordingly.

### Verifying Deposit Transactions

Each transaction includes two signature layers:

1. **FROST Signature**: A threshold Schnorr signature generated by a quorum of custody nodes.  
2. **ECDSA Shield Signature**: A centralized ECDSA signature from the custody shield server.

Both signatures must be verified for the deposit to be considered valid.

ðŸ“„ See `verify_deposit.py` for the complete implementation of the verification logic.

### Parsing a Verified Deposit Transaction

Once a transaction is verified, your application must parse its binary payload to extract one or more deposit events. Each event includes the deposit amount, user ID, token contract, destination, and more.

ðŸ“„ See `parse_deposit.py` for the full parsing logic and format specification.

---

## 3. Submitting Withdrawal Requests

The custody service queries your application for pending withdrawals to sign and submit on-chain. Your app must implement two endpoints:

### Get the Count of Withdrawals

Returns the count of withdrawals for a given chain.

```python
@router.get("/withdraw/count")
def get_last_withdraw_id(chain: str = Query(...)) -> dict[str, int | str]:
    return {"chain": chain, "count": 10}
```

### Get Pending Withdrawals

Returns a paginated list of unsigned withdrawal requests.

```python
class Withdraw(BaseModel):
    chain: str
    tokenContract: str
    amount: str
    destination: str
    user_id: int
    t: int
    id: int

@router.get("/withdraws", response_model=list[Withdraw])
def get_withdraws(
    chain: str = Query(...),
    offset: int = Query(0, ge=0),
    limit: int = Query(10, ge=1, le=100),
):
    ...
```

 **Query Parameters:**

- `chain`: Chain name (e.g., `"SEP"`)
- `offset`: Pagination offset (default: `0`)
- `limit`: Maximum number of withdrawals to return (default: `10`)


ðŸ“„ See `main.py` for the full implementation of the routes that the application should serve and be queried by the custody service.

---

## Run and Test the Server

Install dependencies:

```bash
uv venv
uv pip install -r requirements.txt
```

Start your FastAPI server:

```bash
uv run uvicorn main:app --reload
```

To test the `/deposit` route manually, you can use `curl` with a JSON file that contains `Latin-1` encoded deposit transactions:

```bash
curl -X POST http://localhost:8000/deposit \
  -H "Content-Type: application/json" \
  -d @payload.json
```

Where `payload.json` contains a valid deposit transaction.
